#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
Analysis of data from malware-benchmark-results

Create two big dot plots with the comparison between Androguard and
Kunai analysis, one of the Plots will be for comparing between
size of dex - real time of analysis:


    time of     |
    analysis    |
                |
                |
                |
                |
                -----------------------------
                size of
                dex

And the other will represent the size of dex - memory consumed.

    memory      |
    consumed    |
                |
                |
                |
                |
                -----------------------------
                size of
                dex

With these two plots we will get an idea of the differences between
Kunai and androguard.
'''

import sys
import csv
import statistics
import plotly.graph_objects as go
from database_connector import DatabaseConnector
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

SHOW_LATEX = True
SHOW_PLOT = False

if len(sys.argv) > 1:
    if sys.argv[1] == "-s":
        SHOW_PLOT = True
    

def print_numbers(key, number):
    global SHOW_LATEX
    if SHOW_LATEX:
        print(f"lx.safe_full_number('{key}', {number})")
    else:
        print(f"{key}={number}")


def create_dot_plot(sizes: list, times_androguard: list, times_kunai: list, times_kunai_recursive: list, memory_androguard: list, memory_kunai: list, memory_kunai_recursive: list) -> tuple:
    '''
    Create two dot plots one for size-time and other for size-memory
    '''
    size_time_fig = go.Figure()
    size_time_fig.add_trace(go.Scatter(
        x=sizes,
        y=times_androguard,
        marker=dict(color='crimson', size=12),
        mode="markers",
        name="Androguard"
    ))

    size_time_fig.add_trace(go.Scatter(
        x=sizes,
        y=times_kunai,
        marker=dict(color='blue', size=12),
        mode="markers",
        name="Kunai-Linear"
    ))

    size_time_fig.add_trace(go.Scatter(
        x=sizes,
        y=times_kunai_recursive,
        marker=dict(color='green', size=12),
        mode="markers",
        name="Kunai-Recursive"
    ))

    size_time_fig.update_layout(xaxis_title="DEX file size (bytes)",
                                yaxis_title="Time of analysis (seconds)")

    size_memory_fig = go.Figure()
    size_memory_fig.add_trace(go.Scatter(
        x=sizes,
        y=memory_androguard,
        marker=dict(color='crimson', size=12),
        mode="markers",
        name="Androguard"
    ))

    size_memory_fig.add_trace(go.Scatter(
        x=sizes,
        y=memory_kunai,
        marker=dict(color='blue', size=12),
        mode="markers",
        name="Kunai-Linear"
    ))

    size_memory_fig.add_trace(go.Scatter(
        x=sizes,
        y=memory_kunai_recursive,
        marker=dict(color='green', size=12),
        mode="markers",
        name="Kunai-Recursive"
    ))

    size_memory_fig.update_layout(xaxis_title="DEX file size (bytes)",
                                  yaxis_title="Memory consumed (bytes)")

    return size_time_fig, size_memory_fig


def flip_index(l: list, i: int, j: int) -> list:
    '''
    Simply flip two index from a list.

    :param l: list where to flip the data.
    :param i: first index.
    :param j: second index.
    '''
    temp = l[i]
    l[i] = l[j]
    l[j] = temp
    return l


def create_plot_line(sizes: list, times_androguard: list, times_kunai: list, times_kunai_recursive: list, memory_androguard: list, memory_kunai: list, memory_kunai_recursive: list) -> tuple:
    '''
    Create a plot with a line that represents how it
    grows time and memory usage with the size of the
    DEX, this representation it is similar to previous
    dot plot, but it is easier to visualize, we must
    apply some kind of heuristic (typical deviation
    or the mean) in order to normalize data and avoid
    cases where some data grows a lot or finishes very
    early.

    :param sizes: size of the analyzed files.
    :param times_androguard: time of analysis for androguard.
    :param times_kunai: time of analysis for kunai.
    :param memory_androguard: memory used by androguard for the analysis.
    :param memory_kunai: memory used by kunai for the analysis.
    '''
    global SHOW_PLOT

    df = pd.read_csv('analysis_malware.csv')

    # code by Aymar Cublier

    # Get array of DEX sizes (in bytes)
    X = df.iloc[:, 0].values.reshape(-1, 1) / 1024
    # Get array of execution times Androguard
    T1 = df.iloc[:, 1].values.reshape(-1, 1)
    # Get array of execution times KUNAI
    T2 = df.iloc[:, 2].values.reshape(-1, 1)
    # Get array of execution times KUNAI Recursive
    T3 = df.iloc[:, 3].values.reshape(-1, 1)
    # Get array of memory usage Androguard
    M1 = df.iloc[:, 4].values.reshape(-1, 1) / 1024
    # Get array of memory usage KUNAI
    M2 = df.iloc[:, 5].values.reshape(-1, 1) / 1024
    # Get array of memory usage KUNAI Recursive
    M3 = df.iloc[:, 6].values.reshape(-1, 1) / 1024

    # Get means and std deviation
    muta, sdta = np.mean(T1), np.std(T1)
    mutm, sdtm = np.mean(T2), np.std(T2)
    mutd, sdtd = np.mean(T3), np.std(T3)
    muma, sdma = np.mean(M1), np.std(M1)
    mumm, sdmm = np.mean(M2), np.std(M2)
    mumd, sdmd = np.mean(M3), np.std(M3)

    # Create LinearRegression for series
    lrta = LinearRegression()  # Time Androguard
    lrtm = LinearRegression()  # Time KUNAI
    lrtd = LinearRegression()  # Time KUNAI Recursive
    lrma = LinearRegression()  # Memory Androguard
    lrmm = LinearRegression()  # Memory KUNAI
    lrmd = LinearRegression()

    # Fit and predict times
    lrta.fit(X, T1)
    lrtm.fit(X, T2)
    lrtd.fit(X, T3)
    T1P = lrta.predict(X)     # predict a linear regresion for androguard time
    T2P = lrtm.predict(X)     # predict a linear regresion for kunai time
    T3P = lrtd.predict(X)

    # Fit and predict memory
    lrma.fit(X, M1)
    lrmm.fit(X, M2)
    lrmd.fit(X, M3)
    M1P = lrma.predict(X)
    M2P = lrmm.predict(X)
    M3P = lrmd.predict(X)

    plt.scatter(X, T1, label="Time Androguard ($\mu = %.2f$)" % muta)
    plt.scatter(X, T2, label="Time KUNAI Linear($\mu = %.2f$)" % mutm)
    plt.scatter(X, T3, label="Time KUNAI Recursive($\mu = %.2f$)" % mutd)
    plt.plot(X, T1P, label="Fit Androguard: $R^2 = %.3f$" %
             lrta.score(X, T1), linewidth=3)
    plt.plot(X, T2P, label="Fit KUNAI Linear: $R^2 = %.3f$" %
             lrtm.score(X, T2), linewidth=3)
    plt.plot(X, T3P, label="Fit KUNAI Recursive: $R^2 = %.3f$" %
             lrtd.score(X, T3), linewidth=3)
    plt.xlabel("DEX size (in KB)", fontsize=14)
    plt.ylabel("Execution time (in s)", fontsize=14)

    plt.legend(fontsize=14)
    plt.xticks(range(0, 20000, 2500), fontsize=14)
    plt.yticks(fontsize=14)

    plt.grid()
    plt.savefig("output_plots/Time-Analysis-Malware.png", dpi=400,
                bbox_inches='tight', pad_inches=0.4, format='png')
    if SHOW_PLOT:
        plt.show()

    plt.scatter(X, M1, label="Memory Androguard ($\mu = %.0f$ KB)" % (muma))
    plt.scatter(X, M2, label="Memory KUNAI Linear ($\mu = %.0f$ KB)" % (mumm))
    plt.scatter(X, M3, label="Memory KUNAI Recursive ($\mu = %.0f$ KB)" % (mumd))
    plt.plot(X, M1P, label="Fit Androguard: $R^2 = %.3f$" %
             lrma.score(X, M1), linewidth=3)
    plt.plot(X, M2P, label="Fit KUNAI Linear: $R^2 = %.3f$" %
             lrmm.score(X, M2), linewidth=3)
    plt.plot(X, M3P, label="Fit KUNAI Recursive: $R^2 = %.3f$" %
             lrmd.score(X, M3), linewidth=3)
    plt.xlabel("DEX size (in KB)", fontsize=14)
    plt.ylabel("Memory usage (in KB)", fontsize=14)

    plt.legend(fontsize=14)
    plt.xticks(range(0, 20000, 2500), fontsize=14)
    plt.yticks(range(0, 2000, 250), fontsize=14)

    plt.grid()
    plt.savefig("output_plots/Memory-Analysis-Malware.png",
                dpi=400, pad_inches=0.4, format='png')

    if SHOW_PLOT:
        plt.show()


class InterestingDexFile(object):

    def __init__(self) -> None:
        self.size = 0
        self.md5 = ""
        self.file = ""
        self.time_androguard = 0
        self.time_kunai = 0
        self.time_kunai_recursive = 0
        self.memory_androguard = 0
        self.memory_kunai = 0
        self.memory_kunai_recursive = 0

    def __str__(self) -> str:
        global SHOW_LATEX

        return "File md5: %s, file name: %s, size: %d, time androguard: %f, time kunai: %f, time kunai recursive: %f, memory androguard: %d, memory kunai: %d, memory kunai recursive: %d" % (
            self.md5,
            self.file,
            self.size,
            self.time_androguard,
            self.time_kunai,
            self.time_kunai_recursive,
            self.memory_androguard,
            self.memory_kunai,
            self.memory_kunai_recursive
        )


databaseconnector = DatabaseConnector()

databaseconnector.config()

total_apks = databaseconnector.get_number_of_values_by_query_malware(
    {"analysis": {'$exists': True}})

correct_analysis_of_apks_androguard = 0
correct_analysis_of_apks_kunai = 0

correct_analysis_dex_androguard = 0
correct_analysis_dex_kunai = 0
correct_analysis_dex_kunai_recursive = 0

total_dex_files = 0
correctly_analyzed_dex_files = 0
sizes = list()
md5s = list()
# comparison size_time androguard (use a list to keep repetitions)
size_time_androguard = list()
# comparison size_time kunai
size_time_kunai = list()
# comparison size_time kunai recursive
size_time_kunai_recursive = list()

kunai_faster_androguard = 0
kunai_slower_androguard = 0
kunai_same_time_androguard = 0
kunai_bigger_androguard = 0
kunai_smaller_androguard = 0
kunai_same_size_androguard = 0

# comparison size_memory androguard
size_memory_androguard = list()
# comparison size_memory kunai
size_memory_kunai = list()
# comparison size_memory kunai recursive
size_memory_kunai_recursive = list()

biggest_file = InterestingDexFile()
smallest_file = InterestingDexFile()

complete_analysis_cursor = databaseconnector.retrieve_all_documents_from_malware_collection()

for doc in complete_analysis_cursor:
    if 'benchmark' not in doc['analysis'].keys():
        continue

    for key in doc['analysis']['benchmark'].keys():
        # we are analyzing the APK...
        if '_apk' in key:
            analysis_apk = doc['analysis']['benchmark'][key]

            if analysis_apk['Androguard']['exit_code'] == 0:
                correct_analysis_of_apks_androguard += 1
            if analysis_apk['Kunai']['exit_code'] == 0:
                correct_analysis_of_apks_kunai += 1
        else:
            analysis_dex = doc['analysis']['benchmark'][key]

            total_dex_files += 1

            if analysis_dex['Androguard']['exit_code'] == 0:
                correct_analysis_dex_androguard += 1
            if analysis_dex['Kunai-Linear']['exit_code'] == 0:
                correct_analysis_dex_kunai += 1
            if analysis_dex['Kunai-Recursive']['exit_code'] == 0:
                correct_analysis_dex_kunai_recursive += 1

            if analysis_dex['Androguard']['exit_code'] != 0 or \
                analysis_dex['Kunai-Linear']['exit_code'] != 0 or \
                    analysis_dex['Kunai-Recursive']['exit_code'] != 0:
                print(
                    f"Not correctly analyzed DEX file: pkg_name={doc['md5']}, dex file={key}, androguard={analysis_dex['Androguard']['exit_code']}, Kunai={analysis_dex['Kunai-Linear']['exit_code']}, Kunai Recursive={analysis_dex['Kunai-Recursive']['exit_code']}")
                continue

            correctly_analyzed_dex_files += 1

            size = analysis_dex['Androguard']['file_size']
            time_androguard = analysis_dex['Androguard']['analysis_time']
            memory_androguard = analysis_dex['Androguard']['memory']

            time_kunai_linear = analysis_dex['Kunai-Linear']['analysis_time']
            memory_kunai_linear = analysis_dex['Kunai-Linear']['memory']

            time_kunai_recursive = analysis_dex['Kunai-Recursive']['analysis_time']
            memory_kunai_recursive = analysis_dex['Kunai-Recursive']['memory']


            if time_androguard < time_kunai_linear and time_androguard < time_kunai_recursive:
                kunai_slower_androguard += 1
            elif time_androguard == time_kunai_linear or time_androguard == time_kunai_recursive:
                kunai_same_time_androguard += 1
            else:
                kunai_faster_androguard += 1

            if memory_androguard < memory_kunai_linear and memory_androguard < memory_kunai_recursive:
                kunai_bigger_androguard += 1
            elif memory_androguard == memory_kunai_linear or memory_androguard == memory_kunai_recursive:
                kunai_same_size_androguard += 1
            else:
                kunai_smaller_androguard += 1

            if analysis_dex['Androguard']['file_size'] == 17108:
                print("Detected anomaly with 1708 bytes file, avoiding it")
                print(
                    f"Time Androguard: {time_androguard}, Time Kunai Linear: {time_kunai_linear}, Time Kunai Recursive: {time_kunai_recursive}")
                print(
                    f"Memory Androguard: {memory_androguard}, memory Kunai Linear: {memory_kunai_linear}, memory Kunai Recursive: {memory_kunai_recursive}")
                continue

            md5s.append(doc['md5'])
            sizes.append(size)

            size_time_androguard.append(time_androguard)
            size_time_kunai.append(time_kunai_linear)
            size_time_kunai_recursive.append(time_kunai_recursive)

            size_memory_androguard.append(memory_androguard)
            size_memory_kunai.append(memory_kunai_linear)
            size_memory_kunai_recursive.append(memory_kunai_recursive)

            if size > biggest_file.size:
                biggest_file.size = size
                biggest_file.md5 = doc['md5']
                biggest_file.file = key
                biggest_file.time_androguard = time_androguard
                biggest_file.time_kunai = time_kunai_linear
                biggest_file.time_kunai_recursive = time_kunai_recursive
                biggest_file.memory_androguard = memory_androguard
                biggest_file.memory_kunai = memory_kunai_linear
                biggest_file.memory_kunai_recursive = memory_kunai_recursive

            if smallest_file.size == 0 or size < smallest_file.size:
                smallest_file.size = size
                smallest_file.md5 = doc['md5']
                smallest_file.file = key
                smallest_file.time_androguard = time_androguard
                smallest_file.time_kunai = time_kunai_linear
                smallest_file.time_kunai_recursive = time_kunai_recursive
                smallest_file.memory_androguard = memory_androguard
                smallest_file.memory_kunai = memory_kunai_linear
                smallest_file.memory_kunai_recursive = memory_kunai_recursive


n_analyzed_files = len(sizes)

for i in range(n_analyzed_files):
    for j in range(0, n_analyzed_files-i-1):
        if sizes[j] > sizes[j+1]:
            sizes = flip_index(sizes, j, j+1)
            size_time_androguard = flip_index(size_time_androguard, j, j+1)
            size_time_kunai = flip_index(size_time_kunai, j, j+1)
            size_time_kunai_recursive = flip_index(
                size_time_kunai_recursive, j, j+1)
            size_memory_androguard = flip_index(size_memory_androguard, j, j+1)
            size_memory_kunai = flip_index(size_memory_kunai, j, j+1)
            size_memory_kunai_recursive = flip_index(
                size_memory_kunai_recursive, j, j+1)

with open('analysis_malware.csv', 'w', newline='') as csvfile:
    fieldnames = ['size', 'time_androguard', 'time_kunai', 'time_kunai_recursive', 'memory_androguard', 'memory_kunai', 'memory_kunai_recursive',
                  'time_improve_factor', 'time_improve_factor_recursive', 'memory_improve_factor', 'memory_improve_factor_recursive', 'md5']
    writer = csv.writer(csvfile, delimiter=',',
                        quotechar='|', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(fieldnames)
    for i in range(n_analyzed_files):
        writer.writerow([sizes[i],
                        size_time_androguard[i],
                        size_time_kunai[i],
                        size_time_kunai_recursive[i],
                        size_memory_androguard[i],
                        size_memory_kunai[i],
                        size_memory_kunai_recursive[i],
                        size_time_androguard[i]/size_time_kunai[i],
                        size_time_androguard[i]/size_time_kunai_recursive[i],
                        size_memory_androguard[i]/size_memory_kunai[i],
                        size_memory_androguard[i] /
                         size_memory_kunai_recursive[i],
                        md5s[i]])

fig_size_time, fig_size_mem = create_dot_plot(
    sizes, size_time_androguard, size_time_kunai, size_time_kunai_recursive, size_memory_androguard, size_memory_kunai, size_memory_kunai_recursive)

create_plot_line(
    sizes, size_time_androguard, size_time_kunai, size_time_kunai_recursive, size_memory_androguard, size_memory_kunai, size_memory_kunai_recursive)

print_numbers("totalApksMalware", total_apks)
print_numbers("correctAnalysisApksAndroguardMalware",
              correct_analysis_of_apks_androguard)
print_numbers("correctAnalysisApksKunaiMalware",
              correct_analysis_of_apks_kunai)
print_numbers("correctAnalysisDexAndroguardMalware",
              correct_analysis_dex_androguard)
print_numbers("correctAnalysisDexKunaiLinearMalware",
              correct_analysis_dex_kunai)
print_numbers("correctAnalysisDexKunaiRecursiveMalware",
              correct_analysis_dex_kunai_recursive)
print_numbers("totalDexFilesMalware", total_dex_files)
print_numbers("correctlyAnalyzedDexFileMalware", correctly_analyzed_dex_files)
print("biggest file: ", str(biggest_file))
print("Smallest file: ", str(smallest_file))

print_numbers('kunaiFasterAndroguardMalware', kunai_faster_androguard)
print_numbers('kunaiSlowerAndroguardMalware', kunai_slower_androguard)
print_numbers('kunaiSameTimeAndroguardMalware', kunai_same_time_androguard)

print_numbers('kunaiSmallerAndroguardMalware', kunai_smaller_androguard)
print_numbers('kunaiBiggerAndroguardMalware', kunai_bigger_androguard)
print_numbers('kunaiSameSizeAndroguardMalware', kunai_same_size_androguard)

if SHOW_PLOT:
    fig_size_time.show()
    fig_size_mem.show()
